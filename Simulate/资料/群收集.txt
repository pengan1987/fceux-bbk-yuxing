这个要结合裕兴F型ROM，下断点$7000，按下*号键，正确模拟数据读取端口
应该是读$800个字节到$6000，jmp $6400
调试 vcd $7000有你想要的数据

光盘中的bin头偏移
0：prg个数减1
1：chr个数（=ff无chr）
3：游戏类型
      =1 mmc3
      =2 mapper2
2分屏模式没有切$5501端口
只有可能是ppu点阵空间做镜像

有prg与chr个数定义与游戏类型定义
如mmc3或者mapper2

STA $FF40时回复给$4340一个非零值。下面的画面就是NMI的作用了

软驱一号从并口启动微机通讯卡与DOS里并口联机通信方式大不一样
联机是FF48接收，FF40发送字节。微机通讯卡是4340端口同时负责接和收，4348端口只起校验作用。
发送字节时分两次发送，4348端口发送前固定为#$80,发送完还是#$80.只有中间发送半个字节时4348端口暂时置0.PC端可能要在4340端口发送半个字节成功时给4348端口回复0.4不管怎么说，4348端口始终由学习机STA指令设置数据。但是设置成功不成功需要等待PC端确认。
4340接收字节只需要一次。4348端口同样是接收前和接收后都为#$80,只是接收过程中暂时置0.接收完成后恢复数为#$80.
微机通讯卡启动时，可以直接读写数据块。不计算扇区信息

一、学习机向PC发送一个字节
4348端口是校验功能，4340是数据传送功能。发送字节前，这是准备工作。4348端口必须>=#$80。即最高位bit7=1.发送完毕后，4348端口恢复#$80，以便连续发送。当4348端口=0时，说明正在发送，PC尚未收到并回复。
如果准备工作未完成就调用SendByte功能，学习机将处于死循环状态。如果准备工作完成，就正式发送字节。
要发送的字节是A寄存器的值。
1、先PHA保存下A值。因为A值在传送过程中会被破坏，但是又需要二次调用A值。
2、连续四次左移A值。把A值低4位变成高4位，低4位归0
3、向4340端口发送移位后的A值。完成发送字节的低4位。
4、向4348端口发送0值。此时A=0，4348端口值=80.PC收到4340端口传输来的字节后，就接收4348端口的0值，并回复4348端口一个0值。学习机通过不断bit $4348监听4348端口是否归0。如果不归0则死循环等待PC给4348端口回复0。4348端口收到PC回复的0值后，进入下一步。
5、学习机向PC的4348端口发送80值。并循环等待PC回复80值。做发送字节的准备工作。PC回复80值后，进入下一步。准备发送字节的高4位
6、PLA。从栈中取回原A值。
7、A AND #$F0.把A值低变位直接置0.高4位保持不变。
8、把低4位为0的新A值通过4340端口发送到PC。STA $4340
9、重复步骤4.
10、4348端口回复0后，一个字节8位分两次传送完成。向4348端口发送80。函数结束。函数结果固定A=#$80，4348端口进入和退出时均等于#$80。此时主程序改变A值，再次调用D146功能可以发送下一个字节。因为准备工作已经完成。

二、学习机机从PC接收一个字节
GetByte:	
D17D:2C 48 43	BIT 4348；进入时A=80，要求返回时A=55
D180:10 FB   	BPL D17D *N=0则转移
D182:AD 40 43	LDA 4340；从PC取字节。AA，55，……？
D185:48      	PHA
D186:A9 00   	LDA 00
D188:8D 48 43	STA 4348
D18B:2C 48 43	BIT 4348
D18E:30 FB   	BMI D18B *N=1则转移
D190:A9 80   	LDA 80
D192:8D 48 43	STA 4348
D195:68      	PLA
D196:60      	RTS；从PC取得一个字节
1、检测准备是否就绪。4348端口是否等于#$80.如果不等就死循环等待。
2、LDA $4340.从4340端口接收PC一个字节。
3、PHA。把接收的值入栈保存。
4、向4348端口发送0值。PC从4340向学习机发送一个字节后，收到4348的0值回复学习机4348一个0值。学习机收到0值后进入下一步。
5、此时4348端口值=0。学习机重新向4348端口发送#$80,并等到P回复值80.
6、PLA。从栈中取回A值。返回主程序。函数结束。结果保存在A寄存器。进入和退出时4348端口均等于#$80.
   总结：发送收字节过程开始和结束时4348端口值均等于#$80.但是中间在发送和接收时4348端口须等于0.PC须及时回复0值。发送时分两次发送一字节，接收时一次接收一字节。

检测微机通讯卡过程
1、Y=0
2、从4340端口取数
3、比较4348、4350、4358三端口与4340端口值是否相等
4、如相等即都等于于0，Y=Y-1，循环256次后确认检测失败--》CE17
5、若不相等则--》CDEE，屏显“微机通讯卡”
结论：PC卡启动时4340端口值须不为0.其他三端口为0.

与PC卡建立连接过程（C287，结果A=0=没连通，A<>0=连通微机）：
ConnectPCCard 与PC卡连接：    	
1、开NMI中断
2、向4348发送80，向4340发送A0。PC从4340收到A0后，应回复4340=AA。
3、A=#$14,X=#$19,$5FF8=#$19
4、检测5FF8和4348是否同时等于#$80。中断作用使$5FF8从19向上自动+1。当$5FF8=#$80时进入下一步。
5、向4348发送0，从4340端口取数保存到A和Y。
6、检测5FF8是否等于0（从19连续+1超过FF）.等于0即连通微机失败。
7、检测4348是否写0成功。不成功继续写0，直到成功为止。
8、A=80，并向4348写80.
9、从Y取回A。A是从4340取的值
10、比较A是否等于#$AA.发送的是A0回复的应是AA
11、如果不等于AA则重新从4340取数。
12、X=X-1.若X>0则从第3步开始重复。X从#$14减到0,共重复第3步以上步骤20次。
13、从4340端口须收到20次值等于AA，进入下一步
14、A=55，向PC发送一个字节，并取回一个字节。取回的字节就等于发送字节。
15、若取回字节不等于55则重复发和收。
16、A=5A，向PC发送一个字节表示连通成功。A=1.连通成功。返回主程序。
总结：连通微机过程中，向4348发送和回复值相等。向4340发送A0，回复AA。发送55，回复55.发送5A表示连通完成。转入从微机通讯卡启动过程。
A=02 SendByte;启动开始了。
SaveBlockDirect是不经过CHS参数直接把PC的数据块保存到学习机内存，GetBlockDirect也是直接把学习机数据块操作发送给PC。
PC控制步步高的端口就是4340.收发两用。